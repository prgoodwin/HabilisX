using System;
using MicrosoftResearch.Infer;
using MicrosoftResearch.Infer.Distributions;
using MicrosoftResearch.Infer.Collections;
using MicrosoftResearch.Infer.Factors;

namespace ClinicalTrial
{
	/// <summary>
	/// Generated algorithm for performing inference
	/// </summary>
	/// <remarks>
	/// The easiest way to use this class is to wrap an instance in a CompiledAlgorithm object and use
	/// the methods on CompiledAlgorithm to set parameters and execute inference.
	/// 
	/// If you instead wish to use this class directly, you must perform the following steps:
	/// 1) Create an instance of the class
	/// 2) Set the value of any externally-set fields e.g. data, priors
	/// 3) Call the Execute(numberOfIterations) method
	/// 4) Use the XXXMarginal() methods to retrieve posterior marginals for different variables.
	/// 
	/// Generated by Infer.NET 2.4 beta 4 at 16:28 on 16 August 2012.
	/// </remarks>
	public partial class ClinicalTrialGeneratedCode : IGeneratedAlgorithm
	{
		#region Fields
		/// <summary>Field backing the NumberOfIterationsDone property</summary>
		private int numberOfIterationsDone;
		/// <summary>Field backing the numberPlacebo property</summary>
		private int NumberPlacebo;
		/// <summary>Field backing the placeboGroupOutcomes property</summary>
		private bool[] PlaceboGroupOutcomes;
		/// <summary>Field backing the numberTreated property</summary>
		private int NumberTreated;
		/// <summary>Field backing the treatedGroupOutcomes property</summary>
		private bool[] TreatedGroupOutcomes;
		/// <summary>The number of iterations last computed by Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes. Set this to zero to force re-execution of Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes</summary>
		public int Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes_iterationsDone;
		public DistributionStructArray<Bernoulli,bool> placeboGroupOutcomes_marginal;
		public DistributionStructArray<Bernoulli,bool> treatedGroupOutcomes_marginal;
		/// <summary>Message to marginal of 'isEffective'</summary>
		public Bernoulli isEffective_marginal_F;
		/// <summary>Message to marginal of 'probIfPlacebo'</summary>
		public Beta probIfPlacebo_marginal_F;
		/// <summary>Message to marginal of 'probIfTreated'</summary>
		public Beta probIfTreated_marginal_F;
		/// <summary>Message to marginal of 'probAll'</summary>
		public Beta probAll_marginal_F;
		#endregion

		#region Properties
		/// <summary>The number of iterations done from the initial state</summary>
		public int NumberOfIterationsDone
		{			get {
				return this.numberOfIterationsDone;
			}
		}

		/// <summary>The externally-specified value of 'numberPlacebo'</summary>
		public int numberPlacebo
		{			get {
				return this.NumberPlacebo;
			}
			set {
				if (this.NumberPlacebo!=value) {
					this.NumberPlacebo = value;
					this.numberOfIterationsDone = 0;
					this.Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'placeboGroupOutcomes'</summary>
		public bool[] placeboGroupOutcomes
		{			get {
				return this.PlaceboGroupOutcomes;
			}
			set {
				if ((value!=null)&&(value.Length!=this.NumberPlacebo)) {
					throw new ArgumentException(((("Provided array of length "+value.Length)+" when length ")+this.NumberPlacebo)+" was expected for variable \'placeboGroupOutcomes\'");
				}
				this.PlaceboGroupOutcomes = value;
				this.numberOfIterationsDone = 0;
				this.Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes_iterationsDone = 0;
			}
		}

		/// <summary>The externally-specified value of 'numberTreated'</summary>
		public int numberTreated
		{			get {
				return this.NumberTreated;
			}
			set {
				if (this.NumberTreated!=value) {
					this.NumberTreated = value;
					this.numberOfIterationsDone = 0;
					this.Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes_iterationsDone = 0;
				}
			}
		}

		/// <summary>The externally-specified value of 'treatedGroupOutcomes'</summary>
		public bool[] treatedGroupOutcomes
		{			get {
				return this.TreatedGroupOutcomes;
			}
			set {
				if ((value!=null)&&(value.Length!=this.NumberTreated)) {
					throw new ArgumentException(((("Provided array of length "+value.Length)+" when length ")+this.NumberTreated)+" was expected for variable \'treatedGroupOutcomes\'");
				}
				this.TreatedGroupOutcomes = value;
				this.numberOfIterationsDone = 0;
				this.Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes_iterationsDone = 0;
			}
		}

		#endregion

		#region Methods
		/// <summary>Get the observed value of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		public object GetObservedValue(string variableName)
		{
			if (variableName=="numberPlacebo") {
				return this.numberPlacebo;
			}
			if (variableName=="placeboGroupOutcomes") {
				return this.placeboGroupOutcomes;
			}
			if (variableName=="numberTreated") {
				return this.numberTreated;
			}
			if (variableName=="treatedGroupOutcomes") {
				return this.treatedGroupOutcomes;
			}
			throw new ArgumentException("Not an observed variable name: "+variableName);
		}

		/// <summary>Set the observed value of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		/// <param name="value">Observed value</param>
		public void SetObservedValue(string variableName, object value)
		{
			if (variableName=="numberPlacebo") {
				this.numberPlacebo = (int)value;
				return ;
			}
			if (variableName=="placeboGroupOutcomes") {
				this.placeboGroupOutcomes = (bool[])value;
				return ;
			}
			if (variableName=="numberTreated") {
				this.numberTreated = (int)value;
				return ;
			}
			if (variableName=="treatedGroupOutcomes") {
				this.treatedGroupOutcomes = (bool[])value;
				return ;
			}
			throw new ArgumentException("Not an observed variable name: "+variableName);
		}

		/// <summary>The marginal distribution of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		public object Marginal(string variableName)
		{
			if (variableName=="isEffective") {
				return this.IsEffectiveMarginal();
			}
			if (variableName=="probIfPlacebo") {
				return this.ProbIfPlaceboMarginal();
			}
			if (variableName=="placeboGroupOutcomes") {
				return this.PlaceboGroupOutcomesMarginal();
			}
			if (variableName=="probIfTreated") {
				return this.ProbIfTreatedMarginal();
			}
			if (variableName=="treatedGroupOutcomes") {
				return this.TreatedGroupOutcomesMarginal();
			}
			if (variableName=="probAll") {
				return this.ProbAllMarginal();
			}
			throw new ArgumentException("This class was not built to infer "+variableName);
		}

		public T Marginal<T>(string variableName)
		{
			return Distribution.ChangeType<T>(this.Marginal(variableName));
		}

		/// <summary>The query-specific marginal distribution of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		/// <param name="query">QueryType name. For example, GibbsSampling answers 'Marginal', 'Samples', and 'Conditionals' queries</param>
		public object Marginal(string variableName, string query)
		{
			if (query=="Marginal") {
				return this.Marginal(variableName);
			}
			throw new ArgumentException(((("This class was not built to infer \'"+variableName)+"\' with query \'")+query)+"\'");
		}

		public T Marginal<T>(string variableName, string query)
		{
			return Distribution.ChangeType<T>(this.Marginal(variableName, query));
		}

		/// <summary>The output message of the specified variable.</summary>
		/// <param name="variableName">Variable name</param>
		public object GetOutputMessage(string variableName)
		{
			throw new ArgumentException("This class was not built to compute an output message for "+variableName);
		}

		/// <summary>Update all marginals, by iterating message passing the given number of times</summary>
		/// <param name="numberOfIterations">The number of times to iterate each loop</param>
		/// <param name="initialise">If true, messages that initialise loops are reset when observed values change</param>
		private void Execute(int numberOfIterations, bool initialise)
		{
			this.Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes();
			this.numberOfIterationsDone = numberOfIterations;
		}

		public void Execute(int numberOfIterations)
		{
			this.Execute(numberOfIterations, true);
		}

		public void Update(int additionalIterations)
		{
			this.Execute(this.numberOfIterationsDone+additionalIterations, false);
		}

		private void OnProgressChanged(ProgressChangedEventArgs e)
		{
			// Make a temporary copy of the event to avoid a race condition
			// if the last subscriber unsubscribes immediately after the null check and before the event is raised.
			EventHandler<ProgressChangedEventArgs> handler = this.ProgressChanged;
			if (handler!=null) {
				handler(this, e);
			}
		}

		/// <summary>Reset all messages to their initial values.  Sets NumberOfIterationsDone to 0.</summary>
		public void Reset()
		{
			this.Execute(0);
		}

		/// <summary>Computations that depend on the observed value of numberPlacebo and placeboGroupOutcomes and numberTreated and treatedGroupOutcomes</summary>
		public void Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes()
		{
			if (this.Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes_iterationsDone==1) {
				return ;
			}
			this.placeboGroupOutcomes_marginal = new DistributionStructArray<Bernoulli,bool>(this.NumberPlacebo, delegate(int index0) {
				return ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			});
			this.placeboGroupOutcomes_marginal = Distribution.SetPoint<DistributionStructArray<Bernoulli,bool>,bool[]>(this.placeboGroupOutcomes_marginal, this.PlaceboGroupOutcomes);
			this.treatedGroupOutcomes_marginal = new DistributionStructArray<Bernoulli,bool>(this.NumberTreated, delegate(int index1) {
				return ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			});
			this.treatedGroupOutcomes_marginal = Distribution.SetPoint<DistributionStructArray<Bernoulli,bool>,bool[]>(this.treatedGroupOutcomes_marginal, this.TreatedGroupOutcomes);
			// The constant 'vBernoulli0'
			Bernoulli vBernoulli0 = Bernoulli.FromLogOdds(-1.3862943611198906);
			this.isEffective_marginal_F = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli0);
			Bernoulli[] isEffective_selector_cases_0_uses_B = default(Bernoulli[]);
			// Create array for 'isEffective_selector_cases_0_uses' Backwards messages.
			isEffective_selector_cases_0_uses_B = new Bernoulli[16];
			for(int _ind = 0; _ind<16; _ind++) {
				isEffective_selector_cases_0_uses_B[_ind] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			}
			// The constant 'vBeta0'
			Beta vBeta0 = new Beta(1, 1);
			DistributionStructArray<Beta,double> probIfPlacebo_rep0_B = default(DistributionStructArray<Beta,double>);
			// Create array for 'probIfPlacebo_rep0' Backwards messages.
			probIfPlacebo_rep0_B = new DistributionStructArray<Beta,double>(this.NumberPlacebo);
			for(int index0 = 0; index0<this.NumberPlacebo; index0++) {
				probIfPlacebo_rep0_B[index0] = ArrayHelper.MakeUniform<Beta>(vBeta0);
				// Message to 'probIfPlacebo_rep0' from Bernoulli factor
				probIfPlacebo_rep0_B[index0] = BernoulliFromBetaOp.ProbTrueAverageConditional(this.PlaceboGroupOutcomes[index0]);
			}
			// Buffer for ReplicateOp_Divide.Marginal<Beta>
			Beta probIfPlacebo_rep0_B_toDef = default(Beta);
			// Message to 'probIfPlacebo_rep0' from Replicate factor
			probIfPlacebo_rep0_B_toDef = ReplicateOp_Divide.ToDefInit<Beta>(vBeta0);
			// Message to 'probIfPlacebo_rep0' from Replicate factor
			probIfPlacebo_rep0_B_toDef = ReplicateOp_Divide.ToDef<Beta>(probIfPlacebo_rep0_B, probIfPlacebo_rep0_B_toDef);
			// Buffer for ReplicateOp_Divide.UsesAverageConditional<Beta>
			Beta probIfPlacebo_rep0_F_marginal = default(Beta);
			// Message to 'probIfPlacebo_rep0' from Replicate factor
			probIfPlacebo_rep0_F_marginal = ReplicateOp_Divide.MarginalInit<Beta>(vBeta0);
			// Message to 'probIfPlacebo_rep0' from Replicate factor
			probIfPlacebo_rep0_F_marginal = ReplicateOp_Divide.Marginal<Beta>(probIfPlacebo_rep0_B_toDef, vBeta0, probIfPlacebo_rep0_F_marginal);
			DistributionStructArray<Beta,double> probIfPlacebo_rep0_F = default(DistributionStructArray<Beta,double>);
			// Create array for 'probIfPlacebo_rep0' Forwards messages.
			probIfPlacebo_rep0_F = new DistributionStructArray<Beta,double>(this.NumberPlacebo);
			for(int index0 = 0; index0<this.NumberPlacebo; index0++) {
				probIfPlacebo_rep0_F[index0] = ArrayHelper.MakeUniform<Beta>(vBeta0);
				// Message to 'probIfPlacebo_rep0' from Replicate factor
				probIfPlacebo_rep0_F[index0] = ReplicateOp_Divide.UsesAverageConditional<Beta>(probIfPlacebo_rep0_B[index0], probIfPlacebo_rep0_F_marginal, index0, probIfPlacebo_rep0_F[index0]);
			}
			DistributionStructArray<Bernoulli,bool> isEffective_selector_cases_0_rep0_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'isEffective_selector_cases_0_rep0' Backwards messages.
			isEffective_selector_cases_0_rep0_B = new DistributionStructArray<Bernoulli,bool>(this.NumberPlacebo);
			for(int index0 = 0; index0<this.NumberPlacebo; index0++) {
				isEffective_selector_cases_0_rep0_B[index0] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				// Message to 'isEffective_selector_cases_0_rep0' from Bernoulli factor
				isEffective_selector_cases_0_rep0_B[index0] = Bernoulli.FromLogOdds(BernoulliFromBetaOp.LogEvidenceRatio(this.PlaceboGroupOutcomes[index0], probIfPlacebo_rep0_F[index0]));
			}
			// Message to 'isEffective_selector_cases_0_uses' from Replicate factor
			isEffective_selector_cases_0_uses_B[5] = ReplicateOp_NoDivide.DefAverageConditional<Bernoulli>(isEffective_selector_cases_0_rep0_B, isEffective_selector_cases_0_uses_B[5]);
			// Message to 'isEffective_selector_cases_0_uses' from Replicate factor
			isEffective_selector_cases_0_uses_B[7] = Bernoulli.FromLogOdds(ReplicateOp.LogEvidenceRatio<Beta>(probIfPlacebo_rep0_B, vBeta0, probIfPlacebo_rep0_F));
			DistributionStructArray<Beta,double> probIfTreated_rep0_B = default(DistributionStructArray<Beta,double>);
			// Create array for 'probIfTreated_rep0' Backwards messages.
			probIfTreated_rep0_B = new DistributionStructArray<Beta,double>(this.NumberTreated);
			for(int index1 = 0; index1<this.NumberTreated; index1++) {
				probIfTreated_rep0_B[index1] = ArrayHelper.MakeUniform<Beta>(vBeta0);
				// Message to 'probIfTreated_rep0' from Bernoulli factor
				probIfTreated_rep0_B[index1] = BernoulliFromBetaOp.ProbTrueAverageConditional(this.TreatedGroupOutcomes[index1]);
			}
			// Buffer for ReplicateOp_Divide.Marginal<Beta>
			Beta probIfTreated_rep0_B_toDef = default(Beta);
			// Message to 'probIfTreated_rep0' from Replicate factor
			probIfTreated_rep0_B_toDef = ReplicateOp_Divide.ToDefInit<Beta>(vBeta0);
			// Message to 'probIfTreated_rep0' from Replicate factor
			probIfTreated_rep0_B_toDef = ReplicateOp_Divide.ToDef<Beta>(probIfTreated_rep0_B, probIfTreated_rep0_B_toDef);
			// Buffer for ReplicateOp_Divide.UsesAverageConditional<Beta>
			Beta probIfTreated_rep0_F_marginal = default(Beta);
			// Message to 'probIfTreated_rep0' from Replicate factor
			probIfTreated_rep0_F_marginal = ReplicateOp_Divide.MarginalInit<Beta>(vBeta0);
			// Message to 'probIfTreated_rep0' from Replicate factor
			probIfTreated_rep0_F_marginal = ReplicateOp_Divide.Marginal<Beta>(probIfTreated_rep0_B_toDef, vBeta0, probIfTreated_rep0_F_marginal);
			DistributionStructArray<Beta,double> probIfTreated_rep0_F = default(DistributionStructArray<Beta,double>);
			// Create array for 'probIfTreated_rep0' Forwards messages.
			probIfTreated_rep0_F = new DistributionStructArray<Beta,double>(this.NumberTreated);
			for(int index1 = 0; index1<this.NumberTreated; index1++) {
				probIfTreated_rep0_F[index1] = ArrayHelper.MakeUniform<Beta>(vBeta0);
				// Message to 'probIfTreated_rep0' from Replicate factor
				probIfTreated_rep0_F[index1] = ReplicateOp_Divide.UsesAverageConditional<Beta>(probIfTreated_rep0_B[index1], probIfTreated_rep0_F_marginal, index1, probIfTreated_rep0_F[index1]);
			}
			DistributionStructArray<Bernoulli,bool> isEffective_selector_cases_0_rep1_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'isEffective_selector_cases_0_rep1' Backwards messages.
			isEffective_selector_cases_0_rep1_B = new DistributionStructArray<Bernoulli,bool>(this.NumberTreated);
			for(int index1 = 0; index1<this.NumberTreated; index1++) {
				isEffective_selector_cases_0_rep1_B[index1] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				// Message to 'isEffective_selector_cases_0_rep1' from Bernoulli factor
				isEffective_selector_cases_0_rep1_B[index1] = Bernoulli.FromLogOdds(BernoulliFromBetaOp.LogEvidenceRatio(this.TreatedGroupOutcomes[index1], probIfTreated_rep0_F[index1]));
			}
			// Message to 'isEffective_selector_cases_0_uses' from Replicate factor
			isEffective_selector_cases_0_uses_B[13] = ReplicateOp_NoDivide.DefAverageConditional<Bernoulli>(isEffective_selector_cases_0_rep1_B, isEffective_selector_cases_0_uses_B[13]);
			// Message to 'isEffective_selector_cases_0_uses' from Replicate factor
			isEffective_selector_cases_0_uses_B[15] = Bernoulli.FromLogOdds(ReplicateOp.LogEvidenceRatio<Beta>(probIfTreated_rep0_B, vBeta0, probIfTreated_rep0_F));
			Bernoulli isEffective_selector_cases_0_B = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			// Message to 'isEffective_selector_cases_0' from Replicate factor
			isEffective_selector_cases_0_B = ReplicateOp_NoDivide.DefAverageConditional<Bernoulli>(isEffective_selector_cases_0_uses_B, isEffective_selector_cases_0_B);
			DistributionStructArray<Bernoulli,bool> isEffective_selector_cases_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'isEffective_selector_cases' Backwards messages.
			isEffective_selector_cases_B = new DistributionStructArray<Bernoulli,bool>(2);
			for(int _ind0 = 0; _ind0<2; _ind0++) {
				isEffective_selector_cases_B[_ind0] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			}
			// Message to 'isEffective_selector_cases' from Copy factor
			isEffective_selector_cases_B[0] = ArrayHelper.SetTo<Bernoulli>(isEffective_selector_cases_B[0], isEffective_selector_cases_0_B);
			Bernoulli[] isEffective_selector_cases_1_uses_B = default(Bernoulli[]);
			// Create array for 'isEffective_selector_cases_1_uses' Backwards messages.
			isEffective_selector_cases_1_uses_B = new Bernoulli[13];
			for(int _ind = 0; _ind<13; _ind++) {
				isEffective_selector_cases_1_uses_B[_ind] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			}
			DistributionStructArray<Beta,double> probAll_rep0_B = default(DistributionStructArray<Beta,double>);
			// Create array for 'probAll_rep0' Backwards messages.
			probAll_rep0_B = new DistributionStructArray<Beta,double>(this.NumberPlacebo);
			for(int index0 = 0; index0<this.NumberPlacebo; index0++) {
				probAll_rep0_B[index0] = ArrayHelper.MakeUniform<Beta>(vBeta0);
				// Message to 'probAll_rep0' from Bernoulli factor
				probAll_rep0_B[index0] = BernoulliFromBetaOp.ProbTrueAverageConditional(this.PlaceboGroupOutcomes[index0]);
			}
			// Buffer for ReplicateOp_Divide.Marginal<Beta>
			Beta probAll_rep0_B_toDef = default(Beta);
			// Messages to use of 'probAll'
			Beta[] probAll_use_uses_F = default(Beta[]);
			// Create array for 'probAll_use_uses' Forwards messages.
			probAll_use_uses_F = new Beta[2];
			for(int _ind = 0; _ind<2; _ind++) {
				probAll_use_uses_F[_ind] = ArrayHelper.MakeUniform<Beta>(vBeta0);
			}
			// Message to 'probAll_rep0' from Replicate factor
			probAll_rep0_B_toDef = ReplicateOp_Divide.ToDefInit<Beta>(probAll_use_uses_F[0]);
			// Message to 'probAll_rep0' from Replicate factor
			probAll_rep0_B_toDef = ReplicateOp_Divide.ToDef<Beta>(probAll_rep0_B, probAll_rep0_B_toDef);
			// Messages from use of 'probAll'
			Beta[] probAll_use_uses_B = default(Beta[]);
			// Create array for 'probAll_use_uses' Backwards messages.
			probAll_use_uses_B = new Beta[2];
			for(int _ind = 0; _ind<2; _ind++) {
				probAll_use_uses_B[_ind] = ArrayHelper.MakeUniform<Beta>(vBeta0);
			}
			// Message to 'probAll_use_uses' from Replicate factor
			probAll_use_uses_B[0] = ArrayHelper.SetTo<Beta>(probAll_use_uses_B[0], probAll_rep0_B_toDef);
			DistributionStructArray<Beta,double> probAll_rep1_B = default(DistributionStructArray<Beta,double>);
			// Create array for 'probAll_rep1' Backwards messages.
			probAll_rep1_B = new DistributionStructArray<Beta,double>(this.NumberTreated);
			for(int index1 = 0; index1<this.NumberTreated; index1++) {
				probAll_rep1_B[index1] = ArrayHelper.MakeUniform<Beta>(vBeta0);
				// Message to 'probAll_rep1' from Bernoulli factor
				probAll_rep1_B[index1] = BernoulliFromBetaOp.ProbTrueAverageConditional(this.TreatedGroupOutcomes[index1]);
			}
			// Buffer for ReplicateOp_Divide.Marginal<Beta>
			Beta probAll_rep1_B_toDef = default(Beta);
			// Message to 'probAll_rep1' from Replicate factor
			probAll_rep1_B_toDef = ReplicateOp_Divide.ToDefInit<Beta>(probAll_use_uses_F[1]);
			// Message to 'probAll_rep1' from Replicate factor
			probAll_rep1_B_toDef = ReplicateOp_Divide.ToDef<Beta>(probAll_rep1_B, probAll_rep1_B_toDef);
			// Message to 'probAll_use_uses' from Replicate factor
			probAll_use_uses_B[1] = ArrayHelper.SetTo<Beta>(probAll_use_uses_B[1], probAll_rep1_B_toDef);
			// Buffer for ReplicateOp_Divide.Marginal<Beta>
			Beta probAll_use_uses_B_toDef = default(Beta);
			// Message to 'probAll_use_uses' from Replicate factor
			probAll_use_uses_B_toDef = ReplicateOp_Divide.ToDefInit<Beta>(vBeta0);
			// Message to 'probAll_use_uses' from Replicate factor
			probAll_use_uses_B_toDef = ReplicateOp_Divide.ToDef<Beta>(probAll_use_uses_B, probAll_use_uses_B_toDef);
			// Buffer for ReplicateOp_Divide.UsesAverageConditional<Beta>
			Beta probAll_use_uses_F_marginal = default(Beta);
			// Message to 'probAll_use_uses' from Replicate factor
			probAll_use_uses_F_marginal = ReplicateOp_Divide.MarginalInit<Beta>(vBeta0);
			// Message to 'probAll_use_uses' from Replicate factor
			probAll_use_uses_F_marginal = ReplicateOp_Divide.Marginal<Beta>(probAll_use_uses_B_toDef, vBeta0, probAll_use_uses_F_marginal);
			// Message to 'probAll_use_uses' from Replicate factor
			probAll_use_uses_F[0] = ReplicateOp_Divide.UsesAverageConditional<Beta>(probAll_rep0_B_toDef, probAll_use_uses_F_marginal, 0, probAll_use_uses_F[0]);
			// Message to 'probAll_use_uses' from Replicate factor
			probAll_use_uses_F[1] = ReplicateOp_Divide.UsesAverageConditional<Beta>(probAll_rep1_B_toDef, probAll_use_uses_F_marginal, 1, probAll_use_uses_F[1]);
			// Message to 'isEffective_selector_cases_1_uses' from Replicate factor
			isEffective_selector_cases_1_uses_B[6] = Bernoulli.FromLogOdds(ReplicateOp.LogEvidenceRatio<Beta>(probAll_use_uses_B, vBeta0, probAll_use_uses_F));
			// Buffer for ReplicateOp_Divide.UsesAverageConditional<Beta>
			Beta probAll_rep0_F_marginal = default(Beta);
			// Message to 'probAll_rep0' from Replicate factor
			probAll_rep0_F_marginal = ReplicateOp_Divide.MarginalInit<Beta>(probAll_use_uses_F[0]);
			// Message to 'probAll_rep0' from Replicate factor
			probAll_rep0_F_marginal = ReplicateOp_Divide.Marginal<Beta>(probAll_rep0_B_toDef, probAll_use_uses_F[0], probAll_rep0_F_marginal);
			DistributionStructArray<Beta,double> probAll_rep0_F = default(DistributionStructArray<Beta,double>);
			// Create array for 'probAll_rep0' Forwards messages.
			probAll_rep0_F = new DistributionStructArray<Beta,double>(this.NumberPlacebo);
			for(int index0 = 0; index0<this.NumberPlacebo; index0++) {
				probAll_rep0_F[index0] = ArrayHelper.MakeUniform<Beta>(vBeta0);
				// Message to 'probAll_rep0' from Replicate factor
				probAll_rep0_F[index0] = ReplicateOp_Divide.UsesAverageConditional<Beta>(probAll_rep0_B[index0], probAll_rep0_F_marginal, index0, probAll_rep0_F[index0]);
			}
			DistributionStructArray<Bernoulli,bool> isEffective_selector_cases_1_rep0_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'isEffective_selector_cases_1_rep0' Backwards messages.
			isEffective_selector_cases_1_rep0_B = new DistributionStructArray<Bernoulli,bool>(this.NumberPlacebo);
			for(int index0 = 0; index0<this.NumberPlacebo; index0++) {
				isEffective_selector_cases_1_rep0_B[index0] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				// Message to 'isEffective_selector_cases_1_rep0' from Bernoulli factor
				isEffective_selector_cases_1_rep0_B[index0] = Bernoulli.FromLogOdds(BernoulliFromBetaOp.LogEvidenceRatio(this.PlaceboGroupOutcomes[index0], probAll_rep0_F[index0]));
			}
			// Message to 'isEffective_selector_cases_1_uses' from Replicate factor
			isEffective_selector_cases_1_uses_B[7] = ReplicateOp_NoDivide.DefAverageConditional<Bernoulli>(isEffective_selector_cases_1_rep0_B, isEffective_selector_cases_1_uses_B[7]);
			// Message to 'isEffective_selector_cases_1_uses' from Replicate factor
			isEffective_selector_cases_1_uses_B[9] = Bernoulli.FromLogOdds(ReplicateOp.LogEvidenceRatio<Beta>(probAll_rep0_B, probAll_use_uses_F[0], probAll_rep0_F));
			// Buffer for ReplicateOp_Divide.UsesAverageConditional<Beta>
			Beta probAll_rep1_F_marginal = default(Beta);
			// Message to 'probAll_rep1' from Replicate factor
			probAll_rep1_F_marginal = ReplicateOp_Divide.MarginalInit<Beta>(probAll_use_uses_F[1]);
			// Message to 'probAll_rep1' from Replicate factor
			probAll_rep1_F_marginal = ReplicateOp_Divide.Marginal<Beta>(probAll_rep1_B_toDef, probAll_use_uses_F[1], probAll_rep1_F_marginal);
			DistributionStructArray<Beta,double> probAll_rep1_F = default(DistributionStructArray<Beta,double>);
			// Create array for 'probAll_rep1' Forwards messages.
			probAll_rep1_F = new DistributionStructArray<Beta,double>(this.NumberTreated);
			for(int index1 = 0; index1<this.NumberTreated; index1++) {
				probAll_rep1_F[index1] = ArrayHelper.MakeUniform<Beta>(vBeta0);
				// Message to 'probAll_rep1' from Replicate factor
				probAll_rep1_F[index1] = ReplicateOp_Divide.UsesAverageConditional<Beta>(probAll_rep1_B[index1], probAll_rep1_F_marginal, index1, probAll_rep1_F[index1]);
			}
			DistributionStructArray<Bernoulli,bool> isEffective_selector_cases_1_rep1_B = default(DistributionStructArray<Bernoulli,bool>);
			// Create array for 'isEffective_selector_cases_1_rep1' Backwards messages.
			isEffective_selector_cases_1_rep1_B = new DistributionStructArray<Bernoulli,bool>(this.NumberTreated);
			for(int index1 = 0; index1<this.NumberTreated; index1++) {
				isEffective_selector_cases_1_rep1_B[index1] = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
				// Message to 'isEffective_selector_cases_1_rep1' from Bernoulli factor
				isEffective_selector_cases_1_rep1_B[index1] = Bernoulli.FromLogOdds(BernoulliFromBetaOp.LogEvidenceRatio(this.TreatedGroupOutcomes[index1], probAll_rep1_F[index1]));
			}
			// Message to 'isEffective_selector_cases_1_uses' from Replicate factor
			isEffective_selector_cases_1_uses_B[10] = ReplicateOp_NoDivide.DefAverageConditional<Bernoulli>(isEffective_selector_cases_1_rep1_B, isEffective_selector_cases_1_uses_B[10]);
			// Message to 'isEffective_selector_cases_1_uses' from Replicate factor
			isEffective_selector_cases_1_uses_B[12] = Bernoulli.FromLogOdds(ReplicateOp.LogEvidenceRatio<Beta>(probAll_rep1_B, probAll_use_uses_F[1], probAll_rep1_F));
			Bernoulli isEffective_selector_cases_1_B = ArrayHelper.MakeUniform<Bernoulli>(new Bernoulli());
			// Message to 'isEffective_selector_cases_1' from Replicate factor
			isEffective_selector_cases_1_B = ReplicateOp_NoDivide.DefAverageConditional<Bernoulli>(isEffective_selector_cases_1_uses_B, isEffective_selector_cases_1_B);
			// Message to 'isEffective_selector_cases' from Copy factor
			isEffective_selector_cases_B[1] = ArrayHelper.SetTo<Bernoulli>(isEffective_selector_cases_B[1], isEffective_selector_cases_1_B);
			Bernoulli isEffective_selector_B = ArrayHelper.MakeUniform<Bernoulli>(vBernoulli0);
			// Message to 'isEffective_selector' from Cases factor
			isEffective_selector_B = CasesOp.BAverageConditional(isEffective_selector_cases_B);
			// Message to 'isEffective_marginal' from Variable factor
			this.isEffective_marginal_F = VariableOp.MarginalAverageConditional<Bernoulli>(isEffective_selector_B, vBernoulli0, this.isEffective_marginal_F);
			this.probIfPlacebo_marginal_F = ArrayHelper.MakeUniform<Beta>(vBeta0);
			// Message to 'probIfPlacebo_marginal' from Variable factor
			this.probIfPlacebo_marginal_F = VariableOp.MarginalAverageConditional<Beta>(probIfPlacebo_rep0_B_toDef, vBeta0, this.probIfPlacebo_marginal_F);
			this.probIfTreated_marginal_F = ArrayHelper.MakeUniform<Beta>(vBeta0);
			// Message to 'probIfTreated_marginal' from Variable factor
			this.probIfTreated_marginal_F = VariableOp.MarginalAverageConditional<Beta>(probIfTreated_rep0_B_toDef, vBeta0, this.probIfTreated_marginal_F);
			this.probAll_marginal_F = ArrayHelper.MakeUniform<Beta>(vBeta0);
			// Message to 'probAll_marginal' from Variable factor
			this.probAll_marginal_F = VariableOp.MarginalAverageConditional<Beta>(probAll_use_uses_B_toDef, vBeta0, this.probAll_marginal_F);
			this.Changed_numberPlacebo_placeboGroupOutcomes_numberTreated_treatedGroupOutcomes_iterationsDone = 1;
		}

		/// <summary>
		/// Returns the marginal distribution for 'isEffective' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public Bernoulli IsEffectiveMarginal()
		{
			return this.isEffective_marginal_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'probIfPlacebo' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public Beta ProbIfPlaceboMarginal()
		{
			return this.probIfPlacebo_marginal_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'placeboGroupOutcomes' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public DistributionStructArray<Bernoulli,bool> PlaceboGroupOutcomesMarginal()
		{
			return this.placeboGroupOutcomes_marginal;
		}

		/// <summary>
		/// Returns the marginal distribution for 'probIfTreated' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public Beta ProbIfTreatedMarginal()
		{
			return this.probIfTreated_marginal_F;
		}

		/// <summary>
		/// Returns the marginal distribution for 'treatedGroupOutcomes' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public DistributionStructArray<Bernoulli,bool> TreatedGroupOutcomesMarginal()
		{
			return this.treatedGroupOutcomes_marginal;
		}

		/// <summary>
		/// Returns the marginal distribution for 'probAll' given by the current state of the
		/// message passing algorithm.
		/// </summary>
		/// <returns>The marginal distribution</returns>
		public Beta ProbAllMarginal()
		{
			return this.probAll_marginal_F;
		}

		#endregion

		#region Events
		/// <summary>Event that is fired when the progress of inference changes, typically at the end of one iteration of the inference algorithm.</summary>
		public event EventHandler<ProgressChangedEventArgs> ProgressChanged;
		#endregion

	}

}
